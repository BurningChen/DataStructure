概述：
加载->连接(验证-准备-解析)->初始化->使用->卸载

加载：查找并加载类文件的二进制数据

连接： 就是将已经读入内存的类的二进制数据合并到JVM运行时环境中去，包含如下几个步骤：
1)验证：确保被加载类的正确性
2)准备：未类的静态变量分配内存，并初始化它们
3)解析：把常量池中的符号引用转换成直接引用

初始化：为类的静态变量赋初始值


类加载要完成的功能：
1、通过类的全限定名来获取该类的二进制字节流4
2、把二进制字节流转化为方法区的运行时数据结构
3、在堆上创建一个java.lang.Class对象，用来封装类在方法区内的数据结构，并向外提供了访问方法区内数据结构的接口

加载类的方式：
最常见的方式：本地文件系统中加载，从jar等归档文件中加载
动态的方式：将java源文件动态编译成class
其它方式：网络下载、从专有数据库中加载等等

类加载器：
java虚拟机自带的加载器包括如下几种：
启动类加载器(BootstrapClassLoader)
平台类加载器(PlatformClassLoader)  JDK9以后才有  JDK8: 拓展类加载器：ExtensionClassLoader
应用程序类加载器(AppClassLoader)

用户自定义的加载器，是java.lang.ClassLoader的子类，用户可以定制类的加载方式；
只不过自定义加载器其加载的顺序是在所有系统类加载器的最后


类加载器的关系
父->子
启动类加载器->平台类加载器->应用程序加载器->自定义类加载器

类加载器说明
启动类加载器： 用于加载启动的基础模块类，比如java.base、java.management、java.xml等等
平台类加载器： 用于加载一些平台相关的模块，比如：java.scripting、java.compiler*、java.corba*等等
应用程序类加载器：用于加载应用级别的模块，比如：jdk.compiler、jdk.jartool、jdk.jshell等等；还加载classpath路径中的所有类库
JDK8: 启动类加载器：负责将<JAVA_HOME> /lib,或者-Xbootclasspath参数指定的路径中，且是虚拟机识别的类库加载到内存中(按照名字识别，比如rt.jar,对于不能识别的文件不予装载)
JDK8: 拓展类加载器：负责将<JRE_HOME>/lib/ext,或者java.ext.dirs系统变量所指定路径中的所有类库
JDK8: 应用程序类加载器：负责加载classpath路径中的所有类库
java程序不能直接使用启动类加载器，直接设置classLoader为null，默认就是用启动类加载器
类加载器并不需要等到某个类”首次主动使用“的时候才加载它，Jvm规范允许类加载器在预料到某个类将要使用的时候预先加载它
如果在加载的时候.class文件确实，会在该类首次主动使用时报告LinkageError错误，如果一直没有被使用，就不会报错

双亲委派模型
JVM中的ClassLoader通常采用双亲委派模型，要求除了启动类加载器外，其余的类加载器都应该有自己的父级加载器。这里的父子关系时组合而不是继承，工作过程如下：
1)一个类加载器接受到类加载请求后，首先搜索它的内建加载器定义的所有”具名模块“
2)如果找到了合适的模块定义，将会使用该类加载器来加载
3)如果class没有在这些加载器定义的具名模块中找到，那么将会委托到父级加载器，直到启动类加载器
4)如果父级加载器反馈它不能完成加载请求，比如在它的搜索路径下找不到这个类，那子的类加载器才自己来加载
5)在类路径下找到的类将成为这些加载器的无名模块

双亲委派模型说明
1、双亲委派模型对于保证Java程序的稳定运作很重要
2、实现双亲委派的代码在java.lang.ClassLoader的loadClass()方法中，如果自定义类加载器的话，推荐覆盖实现findClass()方法

类连接主要验证的内容
类文件结构检查：按照JVM规范规定的类文件结构进行
元素据验证： 对字节码描述的信息进行语义分析，保证其符合Java语言规范要求
字节码验证：通过对数据流和控制流进行分析，确保程序语义是合法的和符合逻辑的，这里主要对方法体进行校验
符号引用验证：对类自身以外的信息，也就是常量池中的各种符合引用，进行匹配校验